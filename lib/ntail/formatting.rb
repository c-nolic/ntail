# Autogenerated from a Treetop grammar. Edits may be lost.


module Formatting
  include Treetop::Runtime

  def root
    @root ||= :format_string
  end

  def _nt_format_string
    start_index = index
    if node_cache[:format_string].has_key?(index)
      cached = node_cache[:format_string][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1 = index
      r2 = _nt_token
      if r2
        r1 = r2
      else
        r3 = _nt_literal
        if r3
          r1 = r3
        else
          @index = i1
          r1 = nil
        end
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:format_string][start_index] = r0

    r0
  end

  module Literal0
    def value(log_line, color)
      # context-independent...
      self.text_value
    end
  end

  def _nt_literal
    start_index = index
    if node_cache[:literal].has_key?(index)
      cached = node_cache[:literal][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if index < input_length
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      r0.extend(Literal0)
      @index += 1
    else
      terminal_parse_failure("any character")
      r0 = nil
    end

    node_cache[:literal][start_index] = r0

    r0
  end

  def _nt_token
    start_index = index
    if node_cache[:token].has_key?(index)
      cached = node_cache[:token][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_date
    if r1
      r0 = r1
    else
      r2 = _nt_referer
      if r2
        r0 = r2
      else
        r3 = _nt_remote_address
        if r3
          r0 = r3
        else
          r4 = _nt_request
          if r4
            r0 = r4
          else
            r5 = _nt_status
            if r5
              r0 = r5
            else
              r6 = _nt_user_agent
              if r6
                r0 = r6
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end
      end
    end

    node_cache[:token][start_index] = r0

    r0
  end

  module Date0
    def value(log_line, color)
      log_line.to_date_s.foreground(color)
    end
  end

  def _nt_date
    start_index = index
    if node_cache[:date].has_key?(index)
      cached = node_cache[:date][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%d', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(Date0)
      @index += 2
    else
      terminal_parse_failure('%d')
      r0 = nil
    end

    node_cache[:date][start_index] = r0

    r0
  end

  module Referer0
    def value(log_line, color)
      log_line.to_referer_s.foreground(color).inverse
    end
  end

  def _nt_referer
    start_index = index
    if node_cache[:referer].has_key?(index)
      cached = node_cache[:referer][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%f', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(Referer0)
      @index += 2
    else
      terminal_parse_failure('%f')
      r0 = nil
    end

    node_cache[:referer][start_index] = r0

    r0
  end

  module RemoteAddress0
    def value(log_line, color)
  		"%#{Sickill::Rainbow.enabled ? 15 + 9 : 15}s" % log_line.remote_address.foreground(color)
    end
  end

  def _nt_remote_address
    start_index = index
    if node_cache[:remote_address].has_key?(index)
      cached = node_cache[:remote_address][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%a', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(RemoteAddress0)
      @index += 2
    else
      terminal_parse_failure('%a')
      r0 = nil
    end

    node_cache[:remote_address][start_index] = r0

    r0
  end

  module Request0
    def value(log_line, color)
  		log_line.to_request_s.foreground(color)
    end
  end

  def _nt_request
    start_index = index
    if node_cache[:request].has_key?(index)
      cached = node_cache[:request][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%r', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(Request0)
      @index += 2
    else
      terminal_parse_failure('%r')
      r0 = nil
    end

    node_cache[:request][start_index] = r0

    r0
  end

  module Status0
    def value(log_line, color)
      log_line.status.foreground(color)
    end
  end

  def _nt_status
    start_index = index
    if node_cache[:status].has_key?(index)
      cached = node_cache[:status][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%s', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(Status0)
      @index += 2
    else
      terminal_parse_failure('%s')
      r0 = nil
    end

    node_cache[:status][start_index] = r0

    r0
  end

  module UserAgent0
    def value(log_line, color)
      log_line.to_agent_s.foreground(color)
    end
  end

  def _nt_user_agent
    start_index = index
    if node_cache[:user_agent].has_key?(index)
      cached = node_cache[:user_agent][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%u', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(UserAgent0)
      @index += 2
    else
      terminal_parse_failure('%u')
      r0 = nil
    end

    node_cache[:user_agent][start_index] = r0

    r0
  end

end

class FormattingParser < Treetop::Runtime::CompiledParser
  include Formatting
end


# vim:syntax=ruby
